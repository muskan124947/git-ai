import openai
import os
from typing import Dict, Any

class AIService:
    def __init__(self):
        # Azure OpenAI configuration
        openai.api_type = "azure"
        openai.api_base = os.getenv("AZURE_OPENAI_ENDPOINT")  # e.g., https://your-resource.openai.azure.com/
        openai.api_version = "2023-12-01-preview"
        openai.api_key = os.getenv("AZURE_OPENAI_API_KEY")
        
        self.deployment_name = os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME", "gpt-35-turbo")
        
        if not openai.api_key or not openai.api_base:
            print("⚠️  Warning: Azure OpenAI credentials not found in environment variables")
            print("Please set: AZURE_OPENAI_API_KEY, AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_DEPLOYMENT_NAME")
    
    async def generate_resolution_draft(self, issue_data: Dict[str, Any]) -> str:
        """Generate a resolution draft for a GitHub issue using Azure OpenAI"""
        
        # Construct a detailed prompt with issue context
        prompt = self._build_resolution_prompt(issue_data)
        
        try:
            response = openai.ChatCompletion.create(
                engine=self.deployment_name,  # Use engine instead of model for Azure
                messages=[
                    {
                        "role": "system", 
                        "content": "You are Git.AI, a helpful GitHub issue resolution assistant for maintainers. You analyze issues and provide structured, actionable resolution steps."
                    },
                    {
                        "role": "user", 
                        "content": prompt
                    }
                ],
                max_tokens=4000,
                temperature=0.7
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            # Fallback to a simple template-based response if Azure OpenAI fails
            print(f"Azure OpenAI API error: {str(e)}")
            return self._generate_fallback_response(issue_data)
    
    def _generate_fallback_response(self, issue_data: Dict[str, Any]) -> str:
        """Generate a simple template-based response as fallback"""
        return f"""
**Resolution Steps for Issue #{issue_data['issue_number']}**

1. **Reproduce the issue**: Try to replicate the problem described
2. **Check documentation**: Review README and relevant docs for similar cases
3. **Search similar issues**: Look for related issues in the repository history
4. **Analyze code context**: Check the files/components mentioned in the issue
5. **Provide solution**: Based on findings, suggest a fix or workaround

*Generated by Git.AI Assistant*
"""
    
    def _build_resolution_prompt(self, issue_data: Dict[str, Any]) -> str:
        """Build a structured prompt for AI resolution generation"""
        
        return f"""
**GITHUB ISSUE ANALYSIS REQUEST**

Repository: {issue_data['repo_name']}
Language: {issue_data.get('language', 'Unknown')}
Issue #{issue_data['issue_number']}: {issue_data['issue_title']}

**Issue Description:**
{issue_data['issue_body'] or 'No description provided'}

**Context:**
- Repository Description: {issue_data.get('repo_description', 'No description')}
- Labels: {', '.join(issue_data['labels']) if issue_data['labels'] else 'None'}
- Topics: {', '.join(issue_data['repo_topics']) if issue_data['repo_topics'] else 'None'}
- Reporter: {issue_data['creator']} ({issue_data['creator_type']})

**TASK:**
Provide only a numbered list of 3-5 specific, actionable resolution steps for this GitHub issue. Focus on practical steps a maintainer can take to resolve this specific problem. Do not include classifications, assessments, or response templates - just the resolution steps.

Format as:
1. Step one
2. Step two
3. Step three
etc.
"""
